#!/usr/bin/env python3
"""
Sancov Coverage Tracker for CVC5 Fuzzing

Tracks coverage by reading .sancov files generated by Clang's sanitizer coverage.
Parses binary .sancov files and tracks unique program counters (PCs) to detect
new coverage during fuzzing.
"""

import os
import sys
import struct
import glob
from pathlib import Path
from typing import Set, Dict, Optional
import json


class SancovCoverageTracker:
    """Track coverage using .sancov files."""
    
    def __init__(self, coverage_dir: str = ".", binary_path: Optional[str] = None):
        """
        Initialize coverage tracker.
        
        Args:
            coverage_dir: Directory where .sancov files are written
            binary_path: Path to the instrumented binary (for matching .sancov files)
        """
        self.coverage_dir = Path(coverage_dir)
        self.binary_path = Path(binary_path) if binary_path else None
        self.binary_name = self.binary_path.name if self.binary_path else None
        
        # Track unique PCs (program counters) seen
        self.covered_pcs: Set[int] = set()
        
        # Track coverage per test/file
        self.test_coverage: Dict[str, Set[int]] = {}
        
        # Track which .sancov files we've already processed
        self.processed_files: Set[str] = set()
    
    def parse_sancov_file(self, sancov_path: Path) -> Set[int]:
        """
        Parse a .sancov file and return set of program counters.
        
        Format: Binary file containing array of uint64_t (little-endian)
        """
        pcs = set()
        
        try:
            with open(sancov_path, 'rb') as f:
                data = f.read()
                
                # .sancov files contain array of uint64_t (8 bytes each)
                if len(data) % 8 != 0:
                    print(f"Warning: {sancov_path} size is not multiple of 8 bytes", file=sys.stderr)
                
                # Parse each uint64_t
                for i in range(0, len(data), 8):
                    if i + 8 <= len(data):
                        pc = struct.unpack('<Q', data[i:i+8])[0]  # Little-endian uint64_t
                        if pc != 0:  # Skip zero PCs (padding)
                            pcs.add(pc)
        except Exception as e:
            print(f"Error parsing {sancov_path}: {e}", file=sys.stderr)
        
        return pcs
    
    def find_sancov_files(self, test_id: Optional[str] = None) -> list[Path]:
        """
        Find .sancov files in coverage directory.
        
        If binary_name is set, only match files for that binary.
        Note: .sancov files are named <pid>.<binary_name>.sancov
        """
        # Try multiple patterns to find .sancov files
        patterns = ["*.sancov"]  # All .sancov files
        
        if self.binary_name:
            # Try exact binary name
            patterns.append(f"*.{self.binary_name}.sancov")
            # Also try without extension (in case binary_name includes path)
            binary_base = Path(self.binary_name).name if self.binary_name else None
            if binary_base:
                patterns.append(f"*.{binary_base}.sancov")
        
        all_files = set()
        for pattern in patterns:
            files = list(self.coverage_dir.glob(pattern))
            all_files.update(files)
        
        sancov_files = list(all_files)
        
        # Filter out already processed files
        new_files = [f for f in sancov_files if str(f) not in self.processed_files]
        
        return new_files
    
    def update_coverage(self, test_id: Optional[str] = None) -> Dict[str, int]:
        """
        Update coverage by reading new .sancov files.
        
        Returns:
            Dict with 'new_pcs', 'total_pcs', 'new_files' counts
        """
        sancov_files = self.find_sancov_files(test_id)
        
        # Debug: list all .sancov files if any found
        if sancov_files:
            print(f"[Sancov] Found {len(sancov_files)} .sancov file(s) to process", file=sys.stderr)
        
        new_pcs = set()
        new_files_count = 0
        
        for sancov_file in sancov_files:
            file_str = str(sancov_file)
            
            # Skip if already processed
            if file_str in self.processed_files:
                continue
            
            # Parse file
            pcs = self.parse_sancov_file(sancov_file)
            
            # Track new PCs
            file_new_pcs = pcs - self.covered_pcs
            if file_new_pcs:
                new_pcs.update(file_new_pcs)
                new_files_count += 1
                
                # Update test coverage if test_id provided
                if test_id:
                    if test_id not in self.test_coverage:
                        self.test_coverage[test_id] = set()
                    self.test_coverage[test_id].update(pcs)
            
            # Mark as processed
            self.processed_files.add(file_str)
        
        # Update total coverage
        self.covered_pcs.update(new_pcs)
        
        return {
            'new_pcs': len(new_pcs),
            'total_pcs': len(self.covered_pcs),
            'new_files': new_files_count
        }
    
    def get_coverage_stats(self) -> Dict:
        """Get current coverage statistics."""
        return {
            'total_pcs': len(self.covered_pcs),
            'tests_tracked': len(self.test_coverage),
            'processed_files': len(self.processed_files)
        }
    
    def save_coverage(self, output_file: str):
        """Save coverage data to JSON file."""
        data = {
            'covered_pcs': sorted(list(self.covered_pcs)),
            'test_coverage': {k: sorted(list(v)) for k, v in self.test_coverage.items()},
            'processed_files': sorted(list(self.processed_files)),
            'stats': self.get_coverage_stats()
        }
        
        with open(output_file, 'w') as f:
            json.dump(data, f, indent=2)
    
    def load_coverage(self, input_file: str):
        """Load coverage data from JSON file."""
        with open(input_file, 'r') as f:
            data = json.load(f)
        
        self.covered_pcs = set(data.get('covered_pcs', []))
        self.test_coverage = {k: set(v) for k, v in data.get('test_coverage', {}).items()}
        self.processed_files = set(data.get('processed_files', []))


def main():
    """CLI for testing coverage tracker."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Track sancov coverage')
    parser.add_argument('--coverage-dir', default='.', help='Directory with .sancov files')
    parser.add_argument('--binary', help='Binary name to match .sancov files')
    parser.add_argument('--update', action='store_true', help='Update coverage from new files')
    parser.add_argument('--stats', action='store_true', help='Print coverage statistics')
    parser.add_argument('--save', help='Save coverage to JSON file')
    parser.add_argument('--load', help='Load coverage from JSON file')
    
    args = parser.parse_args()
    
    tracker = SancovCoverageTracker(args.coverage_dir, args.binary)
    
    if args.load:
        tracker.load_coverage(args.load)
        print(f"Loaded coverage from {args.load}")
    
    if args.update:
        result = tracker.update_coverage()
        print(f"New PCs: {result['new_pcs']}, Total PCs: {result['total_pcs']}, New files: {result['new_files']}")
    
    if args.stats:
        stats = tracker.get_coverage_stats()
        print(f"Coverage Statistics:")
        print(f"  Total PCs: {stats['total_pcs']}")
        print(f"  Tests tracked: {stats['tests_tracked']}")
        print(f"  Processed files: {stats['processed_files']}")
    
    if args.save:
        tracker.save_coverage(args.save)
        print(f"Saved coverage to {args.save}")
    
    return 0


if __name__ == '__main__':
    sys.exit(main())

